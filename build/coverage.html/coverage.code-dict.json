{"/home/travis/build/npmtest/node-npmtest-jake/test.js":"/* istanbul instrument in package npmtest_jake */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jake/lib.npmtest_jake.js":"/* istanbul instrument in package npmtest_jake */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jake = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jake = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jake/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jake && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jake */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jake\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jake.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jake.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jake.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jake.__dirname + '/lib.npmtest_jake.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/jake.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar EventEmitter = require('events').EventEmitter;\n// And so it begins\nglobal.jake = new EventEmitter();\n\nvar fs = require('fs')\n  , path = require('path')\n  , chalk = require('chalk')\n  , taskNs = require('./task')\n  , Task = taskNs.Task\n  , FileTask = taskNs.FileTask\n  , DirectoryTask = taskNs.DirectoryTask\n  , Rule = require('./rule').Rule\n  , Namespace = require('./namespace').Namespace\n  , api = require('./api')\n  , utils = require('./utils')\n  , Program = require('./program').Program\n  , Loader = require('./loader').Loader\n  , pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n\nvar MAX_RULE_RECURSION_LEVEL = 16;\n\nvar Invocation = function (taskName, args) {\n  this.taskName = taskName;\n  this.args = args;\n};\n\n// Globalize jake and top-level API methods (e.g., `task`, `desc`)\nutils.mixin(global, api);\n\n// Copy utils onto base jake\nutils.mixin(jake, utils);\n// File utils should be aliased directly on base jake as well\nutils.mixin(jake, utils.file);\n\n// Also add top-level API methods to exported object for those who don't want to\n//   use the globals (`file` here will overwrite the 'file' utils namespace)\nutils.mixin(jake, api);\n\nutils.mixin(jake, new (function () {\n\n  this._invocationChain = [];\n\n  // Private variables\n  // =================\n  // Local reference for scopage\n  var self = this;\n\n  // Public properties\n  // =================\n  this.version = pkg.version;\n  // Used when Jake exits with a specific error-code\n  this.errorCode = undefined;\n  // Loads Jakefiles/jakelibdirs\n  this.loader = new Loader();\n  // Name/value map of all the various tasks defined in a Jakefile.\n  // Non-namespaced tasks are placed into 'default.'\n  this.defaultNamespace = new Namespace('default', null);\n  // For namespaced tasks -- tasks with no namespace are put into the\n  // 'default' namespace so lookup code can work the same for both\n  // namespaced and non-namespaced.\n  this.currentNamespace = this.defaultNamespace;\n  // Saves the description created by a 'desc' call that prefaces a\n  // 'task' call that defines a task.\n  this.currentTaskDescription = null;\n  this.program = new Program();\n  this.FileList = require('filelist').FileList;\n  this.PackageTask = require('./package_task').PackageTask;\n  this.PublishTask = require('./publish_task').PublishTask;\n  this.WatchTask = require('./watch_task').WatchTask;\n  this.TestTask = require('./test_task').TestTask;\n  this.Task = Task;\n  this.FileTask = FileTask;\n  this.DirectoryTask = DirectoryTask;\n  this.Namespace = Namespace;\n  this.Rule = Rule;\n\n  this.parseAllTasks = function () {\n    var _parseNs = function (name, ns) {\n      var nsTasks = ns.tasks\n        , task\n        , nsNamespaces = ns.childNamespaces\n        , fullName;\n      // Iterate through the tasks in each namespace\n      for (var q in nsTasks) {\n        task = nsTasks[q];\n        // Prefix namespaced tasks\n        fullName = name == 'default' ? q : name + ':' + q;\n        // Save with 'taskname' or 'namespace:taskname' key\n        task.fullName = fullName;\n        jake.Task[fullName] = task;\n      }\n      for (var p in nsNamespaces) {\n        fullName = (name == 'default') ? p : name + ':' + p;\n        _parseNs(fullName, nsNamespaces[p]);\n      }\n    };\n\n    _parseNs('default', jake.defaultNamespace);\n  };\n\n  /**\n   * Displays the list of descriptions avaliable for tasks defined in\n   * a Jakefile\n   */\n  this.showAllTaskDescriptions = function (f) {\n    var p\n      , maxTaskNameLength = 0\n      , task\n      , str = ''\n      , padding\n      , name\n      , descr\n      , filter = typeof f == 'string' ? f : null;\n\n    for (p in jake.Task) {\n      task = jake.Task[p];\n      // Record the length of the longest task name -- used for\n      // pretty alignment of the task descriptions\n      maxTaskNameLength = p.length > maxTaskNameLength ?\n        p.length : maxTaskNameLength;\n    }\n    // Print out each entry with descriptions neatly aligned\n    for (p in jake.Task) {\n      if (filter && p.indexOf(filter) == -1) {\n        continue;\n      }\n      task = jake.Task[p];\n\n      //name = '\\033[32m' + p + '\\033[39m ';\n      name = chalk.green(p);\n\n      // Create padding-string with calculated length\n      padding = (new Array(maxTaskNameLength - p.length + 2)).join(' ');\n\n      descr = task.description;\n      if (descr) {\n        descr = chalk.gray(descr);\n        console.log('jake ' + name + padding + descr);\n      }\n    }\n  };\n\n  this.createTask = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , arg\n      , obj\n      , task\n      , type\n      , name\n      , action\n      , opts = {}\n      , prereqs = [];\n\n      type = args.shift();\n\n    // name, [deps], [action]\n    // Name (string) + deps (array) format\n    if (typeof args[0] == 'string') {\n      name = args.shift();\n      if (Array.isArray(args[0])) {\n        prereqs = args.shift();\n      }\n    }\n    // name:deps, [action]\n    // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n    else {\n      obj = args.shift();\n      for (var p in obj) {\n        prereqs = prereqs.concat(obj[p]);\n        name = p;\n      }\n    }\n\n    // Optional opts/callback or callback/opts\n    while ((arg = args.shift())) {\n      if (typeof arg == 'function') {\n        action = arg;\n      }\n      else {\n        opts = arg;\n      }\n    }\n\n    task = jake.currentNamespace.resolveTask(name);\n    if (task && !action) {\n      // Task already exists and no action, just update prereqs, and return it.\n      task.prereqs = task.prereqs.concat(prereqs);\n      return task;\n    }\n\n    switch (type) {\n      case 'directory':\n        action = function () {\n          jake.mkdirP(name);\n        };\n        task = new DirectoryTask(name, prereqs, action, opts);\n        break;\n      case 'file':\n        task = new FileTask(name, prereqs, action, opts);\n        break;\n      default:\n        task = new Task(name, prereqs, action, opts);\n    }\n\n    if (jake.currentTaskDescription) {\n      task.description = jake.currentTaskDescription;\n      jake.currentTaskDescription = null;\n    }\n    jake.currentNamespace.tasks[name] = task;\n    task.namespace = jake.currentNamespace;\n\n    // FIXME: Should only need to add a new entry for the current\n    // task-definition, not reparse the entire structure\n    jake.parseAllTasks();\n\n    return task;\n  };\n\n  this.attemptRule = function (name, ns, level) {\n    var prereqRule\n      , prereq;\n    if (level > MAX_RULE_RECURSION_LEVEL) {\n      return null;\n    }\n    // Check Rule\n    prereqRule = ns.matchRule(name);\n    if (prereqRule) {\n      prereq = prereqRule.createTask(name, level);\n    }\n    return prereq || null;\n  };\n\n  this.createPlaceholderFileTask = function (name, namespace) {\n    var nsPath = ''\n      , filePath = name.split(':').pop() // Strip any namespace\n      , parts\n      , fileTaskName\n      , task\n      , stats;\n\n    if (namespace) {\n      if (typeof namespace == 'string') {\n        nsPath = namespace;\n      }\n      else {\n        nsPath = namespace.path;\n      }\n    }\n\n    parts = nsPath.length ? nsPath.split(':') : [];\n    parts.push(filePath);\n    fileTaskName = parts.join(':');\n\n    task = jake.Task[fileTaskName];\n\n    // If there's not already an existing dummy FileTask for it,\n    // create one\n    if (!task) {\n      // Create a dummy FileTask only if file actually exists\n      if (fs.existsSync(filePath)) {\n        stats = fs.statSync(filePath);\n        task = new jake.FileTask(filePath);\n        task.fullName = fileTaskName;\n        task.modTime = stats.mtime;\n        task.dummy = true;\n        // Put this dummy Task in the global Tasks list so\n        // modTime will be eval'd correctly\n        jake.Task[fileTaskName] = task;\n      }\n    }\n\n    return task || null;\n  };\n\n\n  this.init = function () {\n    var self = this;\n    process.addListener('uncaughtException', function (err) {\n      self.program.handleErr(err);\n    });\n\n  };\n\n  this.run = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , program = this.program\n      , loader = this.loader\n      , preempt\n      , opts;\n\n    program.parseArgs(args);\n    program.init();\n\n    preempt = program.firstPreemptiveOption();\n    if (preempt) {\n      preempt();\n    }\n    else {\n      opts = program.opts;\n      // Load Jakefile and jakelibdir files\n      var jakefileLoaded = loader.loadFile(opts.jakefile);\n      var jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n      if(!jakefileLoaded && !jakelibdirLoaded) {\n        fail('No Jakefile. Specify a valid path with -f/--jakefile, ' +\n            'or place one in the current directory.');\n      }\n\n      program.run();\n    }\n  };\n\n})());\n\nmodule.exports = jake;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/task/index.js":"\nvar Task = require('./task').Task\n  , FileTask = require('./file_task').FileTask\n  , DirectoryTask = require('./directory_task').DirectoryTask;\n\nexports.Task = Task;\nexports.FileTask = FileTask;\nexports.DirectoryTask = DirectoryTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/task/task.js":"var util = require('util') // Native Node util module\n  , path = require('path')\n  , EventEmitter = require('events').EventEmitter\n  , Task\n  , TaskBase\n  , utils = require('../utils')\n  , async = require('async')\n  , rule; // Lazy-require this at the bottom\n\nvar UNDEFINED_VALUE;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.Task\n  @constructor\n  @augments EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nTask = function () {\n  // Do constructor-work only on actual instances, not when used\n  // for inheritance\n  if (arguments.length) {\n    this.init.apply(this, arguments);\n  }\n};\n\nutil.inherits(Task, EventEmitter);\n\nTaskBase = new (function () {\n\n  // Parse any positional args attached to the task-name\n  var parsePrereqName = function (name) {\n        var taskArr = name.split('[')\n          , taskName = taskArr[0]\n          , taskArgs = [];\n        if (taskArr[1]) {\n          taskArgs = taskArr[1].replace(/\\]$/, '');\n          taskArgs = taskArgs.split(',');\n        }\n        return {\n          name: taskName\n        , args: taskArgs\n        };\n      };\n\n  /**\n    @name jake.Task#event:complete\n    @event\n   */\n\n  this.init = function (name, prereqs, action, options) {\n    var opts = options || {};\n\n    this._currentPrereqIndex = 0;\n\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.fullName = null;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.namespace = null;\n    this.parallelLimit = 1;\n\n    // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    }\n    else {\n      if (opts.async) {\n        this.async = true;\n      }\n      if (opts.parallelLimit) {\n        this.parallelLimit = opts.parallelLimit;\n      }\n    }\n\n    //Do a test on self dependencies for this task\n    if(Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n\n  };\n\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n  this.invoke = function () {\n    jake._invocationChain.push(this);\n    this.args = Array.prototype.slice.call(arguments);\n    this.runPrereqs();\n  };\n\n  /**\n    @name jake.Task#execute\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n  this.execute = function () {\n    jake._invocationChain.push(this);\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.run();\n  };\n\n  this.runPrereqs = function () {\n    if (this.prereqs && this.prereqs.length) {\n      if(this.parallelLimit > 1) {\n        var currenttask = this;\n        async.eachLimit(currenttask.prereqs,currenttask.parallelLimit,function(name, cb) {\n\n          var parsed = parsePrereqName(name);\n\n          var prereq = currenttask.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, currenttask.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, currenttask.namespace);\n\n          if (!prereq) {\n            throw new Error('Unknown task \"' + name + '\"');\n          }\n\n          //Test for circular invocation\n          if(prereq === currenttask) {\n            cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n          }\n\n          if (prereq.taskStatus === Task.runStatuses.DONE) {\n            //prereq already done, return\n            cb();\n          } else {\n            //wait for complete before calling cb\n            prereq.once('complete', function () {\n              cb();\n            });\n            //start te prereq if we are the first to encounter it\n            if(prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n              prereq.taskStatus = Task.runStatuses.STARTED;\n              prereq.invoke.apply(prereq, parsed.args);\n            }\n          }\n        }, function(err) {\n          //async callback is called after all prereqs have run.\n          if(err) {\n            throw err;\n          } else {\n            currenttask.run();\n          }\n        });\n      } else {\n        this.nextPrereq();\n      }\n    }\n    else {\n      this.run();\n    }\n  };\n\n  this.nextPrereq = function () {\n    var self = this\n      , index = this._currentPrereqIndex\n      , name = this.prereqs[index]\n      , prereq\n      , parsed\n      , filePath\n      , stats;\n\n    if (name) {\n\n      parsed = parsePrereqName(name);\n\n      prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      }\n\n      // Do when done\n      if (prereq.taskStatus === Task.runStatuses.DONE) {\n        self.handlePrereqComplete(prereq);\n      } else {\n        prereq.once('complete', function () {\n          self.handlePrereqComplete(prereq);\n        });\n        if(prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n           prereq.taskStatus = Task.runStatuses.STARTED;\n           prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  };\n\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n  this.reenable = function (deep) {\n    var prereqs\n      , prereq;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n      for (var i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  };\n\n  this.handlePrereqComplete = function (prereq) {\n    var self = this;\n    this._currentPrereqIndex++;\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      process.nextTick(function () {\n        self.nextPrereq();\n      });\n    }\n    else {\n      this.run();\n    }\n  };\n\n  this.isNeeded = function () {\n    if (this.taskStatus === Task.runStatuses.DONE || typeof this.action != 'function') {\n      return false;\n    }\n    return true;\n  };\n\n  this.run = function () {\n    var runAction = this.isNeeded()\n      , val;\n\n    if (runAction) {\n      this.emit('start');\n      try {\n        val = this.action.apply(this, this.args);\n\n        if (typeof val == 'object' && typeof val.then == 'function') {\n          this.async = true;\n\n          val.then(\n            function(result) {\n              process.nextTick(function() {\n                  complete(result);\n                });\n            },\n            function(err) {\n              process.nextTick(function() {\n                  fail(err);\n                });\n            });\n        }\n      }\n      catch (e) {\n        this.emit('error', e);\n        return; // Bail out, not complete\n      }\n    }\n    else {\n      this.emit('skip');\n    }\n\n    if (!(runAction && this.async)) {\n      this.complete(val);\n    }\n  };\n\n  this.complete = function (val) {\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this),1);\n\n    this._currentPrereqIndex = 0;\n    this.taskStatus = Task.runStatuses.DONE;\n\n    // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n    if (typeof val != 'undefined') {\n      this.value = val;\n    }\n\n    this.emit('complete', this.value);\n  };\n\n})();\nutils.mixin(Task.prototype, TaskBase);\n\nTask.getBaseNamespacePath = function (fullName) {\n  return fullName.split(':').slice(0, -1).join(':');\n};\n\nTask.getBaseTaskName = function (fullName) {\n  return fullName.split(':').pop();\n};\n\n//The task is in one of three states\nTask.runStatuses = {UNSTARTED: 'unstarted', DONE: 'done', STARTED: 'started'};\n\nexports.Task = Task;\n\n// Lazy-require\nrule = require('../rule');\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/utils/index.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n\nvar util = require('util') // Native Node util module\n  , exec = require('child_process').exec\n  , spawn = require('child_process').spawn\n  , EventEmitter = require('events').EventEmitter\n  , utils = require('utilities')\n  , logger = require('./logger')\n  , Exec;\n\nvar parseArgs = function (argumentsObj) {\n    var args\n      , arg\n      , cmds\n      , callback\n      , opts = {\n          interactive: false\n        , printStdout: false\n        , printStderr: false\n        , breakOnError: true\n        };\n\n    args = Array.prototype.slice.call(argumentsObj);\n\n    cmds = args.shift();\n    // Arrayize if passed a single string command\n    if (typeof cmds == 'string') {\n      cmds = [cmds];\n    }\n    // Make a copy if it's an actual list\n    else {\n      cmds = cmds.slice();\n    }\n\n    // Get optional callback or opts\n    while((arg = args.shift())) {\n      if (typeof arg == 'function') {\n        callback = arg;\n      }\n      else if (typeof arg == 'object') {\n        utils.mixin(opts, arg);\n      }\n    }\n\n    // Backward-compat shim\n    if (typeof opts.stdout != 'undefined') {\n      opts.printStdout = opts.stdout;\n      delete opts.stdout;\n    }\n    if (typeof opts.stderr != 'undefined') {\n      opts.printStderr = opts.stderr;\n      delete opts.stderr;\n    }\n\n    return {\n      cmds: cmds\n    , opts: opts\n    , callback: callback\n    };\n};\n\n/**\n  @name jake\n  @namespace jake\n*/\nutils.mixin(utils, new (function () {\n  /**\n    @name jake.exec\n    @static\n    @function\n    @description Executes shell-commands asynchronously with an optional\n    final callback.\n    `\n    @param {String[]} cmds The list of shell-commands to execute\n    @param {Object} [opts]\n      @param {Boolean} [opts.printStdout=false] Print stdout from each command\n      @param {Boolean} [opts.printStderr=false] Print stderr from each command\n      @param {Boolean} [opts.breakOnError=true] Stop further execution on\n      the first error.\n      @param {Boolean} [opts.windowsVerbatimArguments=false] Don't translate\n      arguments on Windows.\n    @param {Function} [callback] Callback to run after executing  the\n    commands\n\n    @example\n    var cmds = [\n          'echo \"showing directories\"'\n        , 'ls -al | grep ^d'\n        , 'echo \"moving up a directory\"'\n        , 'cd ../'\n        ]\n      , callback = function () {\n          console.log('Finished running commands.');\n        }\n    jake.exec(cmds, {stdout: true}, callback);\n   */\n  this.exec = function (a, b, c) {\n    var parsed = parseArgs(arguments)\n      , cmds = parsed.cmds\n      , opts = parsed.opts\n      , callback = parsed.callback;\n\n    var ex = new Exec(cmds, opts, callback);\n\n    ex.addListener('error', function (msg, code) {\n      if (opts.breakOnError) {\n        fail(msg, code);\n      }\n    });\n    ex.run();\n\n    return ex;\n  };\n\n  this.createExec = function (a, b, c) {\n    return new Exec(a, b, c);\n  };\n\n})());\n\nExec = function () {\n  var parsed = parseArgs(arguments)\n    , cmds = parsed.cmds\n    , opts = parsed.opts\n    , callback = parsed.callback;\n\n  this._cmds = cmds;\n  this._callback = callback;\n  this._config = opts;\n};\n\nutil.inherits(Exec, EventEmitter);\n\nutils.mixin(Exec.prototype, new (function () {\n\n  var _run = function () {\n        var self = this\n          , sh\n          , cmd\n          , args\n          , next = this._cmds.shift()\n          , config = this._config\n          , errData = ''\n          , shStdio\n          , handleStdoutData = function (data) {\n              self.emit('stdout', data);\n            }\n          , handleStderrData = function (data) {\n              var d = data.toString();\n              self.emit('stderr', data);\n              // Accumulate the error-data so we can use it as the\n              // stack if the process exits with an error\n              errData += d;\n            };\n\n        // Keep running as long as there are commands in the array\n        if (next) {\n          var spawnOpts = {};\n          this.emit('cmdStart', next);\n\n          // Ganking part of Node's child_process.exec to get cmdline args parsed\n          if (process.platform == 'win32') {\n            cmd = 'cmd';\n            args = ['/c', next];\n            if (config.windowsVerbatimArguments) {\n              spawnOpts.windowsVerbatimArguments = true;\n            }\n          }\n          else {\n            cmd = '/bin/sh';\n            args = ['-c', next];\n          }\n\n          if (config.interactive) {\n            spawnOpts.stdio = 'inherit';\n            sh = spawn(cmd, args, spawnOpts);\n          }\n          else {\n            shStdio = [\n              process.stdin\n            ];\n            if (config.printStdout) {\n              shStdio.push(process.stdout);\n            }\n            else {\n              shStdio.push('pipe');\n            }\n            if (config.printStderr) {\n              shStdio.push(process.stderr);\n            }\n            else {\n              shStdio.push('pipe');\n            }\n            spawnOpts.stdio = shStdio;\n            sh = spawn(cmd, args, spawnOpts);\n            if (!config.printStdout) {\n              sh.stdout.addListener('data', handleStdoutData);\n            }\n            if (!config.printStderr) {\n              sh.stderr.addListener('data', handleStderrData);\n            }\n          }\n\n          // Exit, handle err or run next\n          sh.on('exit', function (code) {\n            var msg;\n            if (code !== 0) {\n              msg = errData || 'Process exited with error.';\n              msg = utils.string.trim(msg);\n              self.emit('error', msg, code);\n            }\n            if (code === 0 || !config.breakOnError) {\n              self.emit('cmdEnd', next);\n              setTimeout(function () { _run.call(self); }, 0);\n            }\n          });\n\n        }\n        else {\n          self.emit('end');\n          if (typeof self._callback == 'function') {\n            self._callback();\n          }\n        }\n      };\n\n  this.append = function (cmd) {\n    this._cmds.push(cmd);\n  };\n\n  this.run = function () {\n    _run.call(this);\n  };\n\n})());\n\nutils.Exec = Exec;\nutils.logger = logger;\n\nmodule.exports = utils;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/utils/logger.js":"var util = require('util');\n\nvar logger = new (function () {\n  var _output = function (type, out) {\n    var quiet = typeof jake != 'undefined' && jake.program &&\n        jake.program.opts && jake.program.opts.quiet\n      , msg;\n    if (!quiet) {\n      msg = typeof out == 'string' ? out : util.inspect(out);\n      console[type](msg);\n    }\n  };\n\n  this.log = function (out) {\n    _output('log', out);\n  };\n\n  this.error = function (out) {\n    _output('error', out);\n  };\n\n})();\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/rule.js":"var path = require('path')\n  , fs = require('fs')\n  , Task = require('./task/task').Task\n  , Matcher\n  , rule = {}\n  , Rule;\n\n// Define a helper object with some utility functions\nMatcher = new (function () {\n\n  // Split a task to two parts, name space and task name.\n  // For example, given 'foo:bin/a%.c', return an object with\n  // - 'ns'     : foo\n  // - 'name'   : bin/a%.c\n  this.split = function(task) {\n    var parts = task.split(':')\n    , name  = parts.pop()\n    , ns    = this.resolveNS( parts );\n    return {\n      'name' : name,\n      'ns'   : ns\n    };\n  };\n\n  // Return the namespace based on an array of names.\n  // For example, given ['foo', 'baz' ], return the namespace\n  //\n  //   default -> foo -> baz\n  //\n  // where default is the global root namespace\n  // and -> means child namespace.\n  this.resolveNS = function(parts) {\n    var  ns    = jake.defaultNamespace;\n    for(var i = 0, l = parts.length; ns && i < l; i++) {\n      ns = ns.childNamespaces[parts[i]];\n    }\n    return ns;\n  };\n\n  // Given a pattern p, say 'foo:bin/a%.c'\n  // Return an object with\n  // - 'ns'     : foo\n  // - 'dir'    : bin\n  // - 'prefix' : a\n  // - 'suffix' : .c\n  this.resolve = function(p) {\n    var task = this.split(p),\n        name  = task.name,\n        ns    = task.ns;\n    var split = path.basename(name).split('%');\n    return {\n      ns: ns\n    , dir: path.dirname(name)\n    , prefix: split[0]\n    , suffix: split[1]\n    };\n  };\n\n  // Test whether string a is a suffix of string b\n  this.stringEndWith = function (a,b) {\n    var l;\n    return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n  };\n\n  // Replace the suffix a of the string s with b.\n  // Note that, it is assumed a is a suffix of s.\n  this.stringReplaceSuffix = function (s, a, b) {\n    return s.slice(0,s.lastIndexOf(a)) + b;\n  };\n\n  // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n  this.match = function(pattern, name) {\n    var p\n      , task\n      , ns\n      , obj\n      , filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    }\n    else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return this.stringEndWith(pattern, name);\n    }\n    else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = this.resolve(pattern);\n\n      // Resolve the namespace and task-name\n      task = this.split(name);\n      name = task.name;\n      ns = task.ns;\n\n      // Set the objective as the task-name\n      obj = name;\n\n      // Namespace is already matched.\n\n      // Check dir\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj);\n\n      // Check file name length\n      if ((p.prefix.length + p.suffix.length + 1) > filename.length) {\n        // Length does not match.\n        return false;\n      }\n\n      // Check prefix\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      }\n\n      // Check suffix\n      if (!this.stringEndWith(p.suffix, filename)) {\n        return false;\n      }\n\n      // OK. Find a match.\n      return true;\n    }\n  };\n\n  // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n  this.getSource = function(name, pattern, source) {\n    var dep\n      , pat\n      , match\n      , file\n      , src;\n\n    // Regex pattern -- use to look up the extension\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = this.stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    }\n    // Assume string\n    else {\n      // Simple string suffix replacement\n      if (pattern.indexOf('%') == -1) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = this.stringReplaceSuffix(name, pattern, source);\n        }\n      }\n      // Percent-based substitution\n      else {\n        pat = pattern.replace('%', '(.*?)');\n        pat = new RegExp(pat);\n        match = pat.exec(name);\n        if (match) {\n          if (typeof source == 'function') {\n            src = source(name);\n          }\n          else {\n            file = match[1];\n            file = source.replace('%', file);\n            dep = match[0];\n            src = name.replace(dep, file);\n          }\n        }\n      }\n    }\n\n    return src;\n  };\n\n})();\n\n\nRule = function (opts) {\n  this.pattern = opts.pattern;\n  this.source = opts.source;\n  this.prereqs = opts.prereqs;\n  this.action = opts.action;\n  this.opts = opts.opts;\n  this.desc =  opts.desc;\n  this.ns = opts.ns;\n};\n\nRule.prototype = new (function () {\n  // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n  this.createTask = function (fullName, level) {\n    var self = this\n      , pattern\n      , source\n      , action\n      , opts\n      , prereqs\n      , parts\n      , valid\n      , src\n      , tNs\n      , createdTask\n      , name = Task.getBaseTaskName(fullName)\n      , nsPath = Task.getBaseNamespacePath(fullName)\n      , ns = this.ns.resolveNamespace(nsPath);\n\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Matcher.getSource(name, pattern, source);\n    }\n    else {\n      src = source(name);\n    }\n\n    // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':');\n\n    // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n    prereqs.unshift(src);\n\n    // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n    valid = prereqs.some(function (p) {\n      var ns = self.ns;\n      return ns.resolveTask(p) ||\n        fs.existsSync(Task.getBaseTaskName(p)) ||\n        jake.attemptRule(p, ns, level + 1);\n    });\n\n    // If any of the prereqs aren't valid, the rule isn't valid\n    if (!valid) {\n      return null;\n    }\n    // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n      // Create the action for the task\n      action = function () {\n        var task = this;\n        self.action.apply(task);\n      };\n\n      opts = this.opts;\n\n      // Insert the file task into Jake\n      //\n      // Since createTask function stores the task as a child task\n      // of currentNamespace. Here we temporariliy switch the namespace.\n      // FIXME: Should allow optional ns passed in instead of this hack\n      tNs = jake.currentNamespace;\n      jake.currentNamespace = ns;\n      createdTask = jake.createTask('file', name, prereqs, action, opts);\n      createdTask.source = src.split(':').pop();\n      jake.currentNamespace = tNs;\n\n      return createdTask;\n    }\n\n  };\n\n  this.match = function (name) {\n    return Matcher.match(this.pattern, name);\n  };\n\n})();\n\nrule.Rule = Rule;\nrule.Matcher = Matcher;\n\nmodule.exports = rule;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/task/file_task.js":"var fs = require('fs')\n  , Task = require('./task').Task\n  , FileTask\n  , FileBase\n  , DirectoryTask\n  , utils = require('../utils');\n\nFileBase = new (function () {\n  var isFileOrDirectory = function (t) {\n        return (t instanceof FileTask ||\n            t instanceof DirectoryTask);\n      }\n    , isFile = function (t) {\n        return (t instanceof FileTask && !(t instanceof DirectoryTask));\n      };\n\n  this.isNeeded = function () {\n    var runAction = false\n      , prereqs = this.prereqs\n      , prereqName\n      , prereqTask;\n\n    // No repeatsies\n    if (this.taskStatus === Task.runStatuses.DONE) {\n      return false;\n    }\n    // The always-make override\n    else if (jake.program.opts['always-make']) {\n      // Run if there actually is an action\n      if (typeof this.action == 'function') {\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n    // Default case\n    else {\n      // We need either an existing file, or an action to create one.\n      // First try grabbing the actual mod-time of the file\n      try {\n        this.updateModTime();\n      }\n      // Then fall back to looking for an action\n      catch(e) {\n        if (typeof this.action == 'function') {\n          return true;\n        }\n        else {\n          throw new Error('File-task ' + this.fullName + ' has no ' +\n            'existing file, and no action to create one.');\n        }\n      }\n\n      // Compare mod-time of all the prereqs with its mod-time\n      // If any prereqs are newer, need to run the action to update\n      if (prereqs && prereqs.length) {\n        for (var i = 0, ii = prereqs.length; i < ii; i++) {\n          prereqName = prereqs[i];\n          prereqTask = this.namespace.resolveTask(prereqName) ||\n            jake.createPlaceholderFileTask(prereqName, this.namespace);\n          // Run the action if:\n          // 1. The prereq is a normal task (not file/dir)\n          // 2. The prereq is a file-task with a mod-date more recent than\n          // the one for this file/dir\n          if (prereqTask) {\n            if (!isFileOrDirectory(prereqTask) ||\n                (isFile(prereqTask) && prereqTask.modTime > this.modTime)) {\n              return true;\n            }\n          }\n        }\n      }\n      // File/dir has no prereqs, and exists -- no need to run\n      else {\n        return false;\n      }\n    }\n  };\n\n  this.updateModTime = function () {\n    var stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  };\n\n  this.complete = function () {\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this),1);\n    if (!this.dummy) {\n      this.updateModTime();\n    }\n    this._currentPrereqIndex = 0;\n    this.taskStatus = Task.runStatuses.DONE;\n    this.emit('complete');\n  };\n\n})();\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.FileTask\n  @constructor\n  @augments EventEmitter\n  @augments jake.Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nFileTask = function (name, prereqs, action, opts) {\n  this.modTime = null;\n  this.dummy = false;\n  // Do constructor-work only on actual instances, not when used\n  // for inheritance\n  if (arguments.length) {\n    this.init.apply(this, arguments);\n  }\n};\nFileTask.prototype = new Task();\nFileTask.prototype.constructor = FileTask;\nutils.mixin(FileTask.prototype, FileBase);\n\nexports.FileTask = FileTask;\n\n// DirectoryTask is a subclass of FileTask, depends on it\n// being defined\nDirectoryTask = require('./directory_task').DirectoryTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/task/directory_task.js":"var DirectoryTask\n  , FileTask = require('./file_task').FileTask;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.DirectoryTask\n  @constructor\n  @augments EventEmitter\n  @augments jake.Task\n  @augments jake.FileTask\n  @description A Jake DirectoryTask\n\n  @param {String} name The name of the directory to create.\n */\nDirectoryTask = function (name) {\n  this.modTime = null;\n  // Do constructor-work only on actual instances, not when used\n  // for inheritance\n  if (arguments.length) {\n    this.init.apply(this, arguments);\n  }\n};\nDirectoryTask.prototype = new FileTask();\nDirectoryTask.prototype.constructor = DirectoryTask;\n\nexports.DirectoryTask = DirectoryTask;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/namespace.js":"\nvar Namespace = function (name, parentNamespace) {\n  this.name = name;\n  this.parentNamespace = parentNamespace;\n  this.childNamespaces = {};\n  this.tasks = {};\n  this.rules = {};\n  this.path = this.getPath();\n};\n\nNamespace.prototype = new (function () {\n\n  this.resolveTask = function(relativeName) {\n    var parts = relativeName.split(':')\n      , name = parts.pop()\n      , ns = this.resolveNamespace(parts.join(':'));\n\n    return (ns && ns.tasks[name]) ||\n        (this.parentNamespace &&\n        this.parentNamespace.resolveTask(relativeName));\n  };\n\n  this.resolveNamespace = function(relativeName) {\n    var parts = relativeName.split(':')\n      , ns;\n\n    if (!relativeName) {\n      return this;\n    }\n\n    ns = this;\n    for (var i = 0, ii = parts.length; ns && i < ii; i++) {\n      ns = ns.childNamespaces[parts[i]];\n    }\n\n    return (ns || (this.parentNamespace &&\n        this.parentNamespace.resolveNamespace(relativeName)));\n  };\n\n  this.matchRule = function(relativeName) {\n    var parts = relativeName.split(':')\n      , name = parts.pop()\n      , ns = this.resolveNamespace(parts.join(':'))\n      , rules = ns ? ns.rules : []\n      , r\n      , match;\n\n    for (var p in rules) {\n      r = rules[p];\n      if (r.match(relativeName)) {\n        match = r;\n      }\n    }\n\n    return (ns && match) ||\n        (this.parentNamespace &&\n        this.parentNamespace.matchRule(relativeName));\n  };\n\n  this.getPath = function () {\n    var parts = []\n      , next = this;\n    while (!!next) {\n      parts.push(next.name);\n      next = next.parentNamespace;\n    }\n    parts.pop(); // Remove 'default'\n    return parts.reverse().join(':');\n  };\n\n})();\n\nmodule.exports.Namespace = Namespace;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/api.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar api = new (function () {\n  /**\n    @name task\n    @static\n    @function\n    @description Creates a Jake Task\n    `\n    @param {String} name The name of the Task\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n    @example\n    desc('This is the default task.');\n    task('default', function (params) {\n      console.log('This is the default task.');\n    });\n\n    desc('This task has prerequisites.');\n    task('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {\n      console.log('Ran some prereqs first.');\n    });\n\n    desc('This is an asynchronous task.');\n    task('asyncTask', function () {\n      setTimeout(complete, 1000);\n    }, {async: true});\n   */\n  this.task = function (name, prereqs, action, opts) {\n    var args = Array.prototype.slice.call(arguments)\n      , type\n      , createdTask;\n    args.unshift('task');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name rule\n    @static\n    @function\n    @description Creates a Jake Suffix Rule\n    `\n    @param {String} pattern The suffix name of the objective\n    @param {String} source The suffix name of the objective\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n    @example\n    desc('This is a rule, which does not support namespace or pattern.');\n    rule('.o', '.c', {async: true}, function () {\n      var cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has prerequisites.');\n    rule('.o', '.c', ['util.h'], {async: true}, function () {\n      var cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is a rule with patterns.');\n    rule('%.o', '%.c', {async: true}, function () {\n      var cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is another rule with patterns.');\n    rule('obj/%.o', 'src/%.c', {async: true}, function () {\n      var cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is an example with chain rules.');\n    rule('%.pdf', '%.dvi', {async: true}, function () {\n      var cmd = util.format('dvipdfm %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    rule('%.dvi', '%.tex', {async: true}, function () {\n      var cmd = util.format('latex %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has a namespace.');\n    task('default', ['debug:obj/main.o]);\n\n    namespace('debug', {async: true}, function() {\n      rule('obj/%.o', 'src/%.c', function () {\n        // ...\n      });\n    }\n   */\n  this.rule = function () {\n    var args = Array.prototype.slice.call(arguments)\n      , arg\n      , pattern = args.shift()\n      , source = args.shift()\n      , prereqs = []\n      , action = function () {}\n      , opts = {}\n      , key = pattern.toString(); // May be a RegExp\n\n    while ((arg = args.shift())) {\n      if (typeof arg == 'function') {\n        action = arg;\n      }\n      else if (Array.isArray(arg)) {\n        prereqs = arg;\n      }\n      else {\n        opts = arg;\n      }\n    }\n\n    jake.currentNamespace.rules[key] = new jake.Rule({\n      pattern: pattern\n    , source: source\n    , prereqs: prereqs\n    , action: action\n    , opts: opts\n    , desc: jake.currentTaskDescription\n    , ns: jake.currentNamespace\n    });\n    jake.currentTaskDescription = null;\n  };\n\n  /**\n    @name directory\n    @static\n    @function\n    @description Creates a Jake DirectoryTask. Can be used as a prerequisite\n    for FileTasks, or for simply ensuring a directory exists for use with a\n    Task's action.\n    `\n    @param {String} name The name of the DiretoryTask\n\n    @example\n\n    // Creates the package directory for distribution\n    directory('pkg');\n   */\n  this.directory = function (name) {\n    var args = Array.prototype.slice.call(arguments)\n      , createdTask;\n    args.unshift('directory');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name file\n    @static\n    @function\n    @description Creates a Jake FileTask.\n    `\n    @param {String} name The name of the FileTask\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to create this file, if it doesn't\n    exist already.\n    @param {Object} [opts]\n      @param {Array} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n   */\n  this.file = function (name, prereqs, action, opts) {\n    var args = Array.prototype.slice.call(arguments)\n      , createdTask;\n    args.unshift('file');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name desc\n    @static\n    @function\n    @description Creates a description for a Jake Task (or FileTask,\n    DirectoryTask). When invoked, the description that iscreated will\n    be associated with whatever Task is created next.\n    `\n    @param {String} description The description for the Task\n   */\n  this.desc = function (description) {\n    jake.currentTaskDescription = description;\n  };\n\n  /**\n    @name namespace\n    @static\n    @function\n    @description Creates a namespace which allows logical grouping\n    of tasks, and prevents name-collisions with task-names. Namespaces\n    can be nested inside of other namespaces.\n    `\n    @param {String} name The name of the namespace\n    @param {Function} scope The enclosing scope for the namespaced tasks\n\n    @example\n    namespace('doc', function () {\n      task('generate', ['doc:clobber'], function () {\n        // Generate some docs\n      });\n\n      task('clobber', function () {\n        // Clobber the doc directory first\n      });\n    });\n   */\n  this.namespace = function (name, closure) {\n    var curr = jake.currentNamespace\n      , ns = curr.childNamespaces[name] || new jake.Namespace(name, curr);\n    curr.childNamespaces[name] = ns;\n    jake.currentNamespace = ns;\n    closure();\n    jake.currentNamespace = curr;\n    jake.currentTaskDescription = null;\n    return ns;\n  };\n\n  /**\n    @name complete\n    @static\n    @function\n    @description Completes an asynchronous task, allowing Jake's\n    execution to proceed to the next task. Calling complete globally or without\n    arguments completes the last task on the invocationChain. If you use parallel\n    execution of prereqs this will probably complete a wrong task. You should call this\n    function with this task as the first argument, before the optional return value.\n    Alternatively you can call task.complete()\n    `\n    @example\n    task('generate', ['doc:clobber'], function () {\n      exec('./generate_docs.sh', function (err, stdout, stderr) {\n        if (err || stderr) {\n          fail(err || stderr);\n        }\n        else {\n          console.log(stdout);\n          complete();\n        }\n      });\n    }, {async: true});\n   */\n  this.complete = function (task, val) {\n    //this should detect if the first arg is a task, but I guess it should be more thorough\n    if(task && task. _currentPrereqIndex >=0 ) {\n      task.complete(val);\n    } else {\n      val = task;\n      if(jake._invocationChain.length > 0) {\n        jake._invocationChain[jake._invocationChain.length-1].complete(val);\n      } else {\n      }\n    }\n  };\n\n  /**\n    @name fail\n    @static\n    @function\n    @description Causes Jake execution to abort with an error.\n    Allows passing an optional error code, which will be used to\n    set the exit-code of exiting process.\n    `\n    @param {Error|String} err The error to thow when aborting execution.\n    If this argument is an Error object, it will simply be thrown. If\n    a String, it will be used as the error-message. (If it is a multi-line\n    String, the first line will be used as the Error message, and the\n    remaining lines will be used as the error-stack.)\n\n    @example\n    task('createTests, function () {\n      if (!fs.existsSync('./tests')) {\n        fail('Test directory does not exist.');\n      }\n      else {\n        // Do some testing stuff ...\n      }\n    });\n   */\n  this.fail = function (err, code) {\n    var msg\n      , errObj;\n    if (code) {\n      jake.errorCode = code;\n    }\n    if (err) {\n      if (typeof err == 'string') {\n        // Use the initial or only line of the error as the error-message\n        // If there was a multi-line error, use the rest as the stack\n        msg = err.split('\\n');\n        errObj = new Error(msg.shift());\n        if (msg.length) {\n          errObj.stack = msg.join('\\n');\n        }\n        throw errObj;\n      }\n      else if (err instanceof Error) {\n        throw err;\n      }\n      else {\n        throw new Error(err.toString());\n      }\n    }\n    else {\n      throw new Error();\n    }\n  };\n\n  this.packageTask = function (name, version, definition) {\n    return new jake.PackageTask(name, version, definition);\n  };\n\n  this.publishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  // Backward-compat\n  this.npmPublishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  this.watchTask = function (name, taskNames, definition) {\n    return new jake.WatchTask(name, taskNames, definition);\n  };\n\n  this.testTask = function () {\n    var ctor = function () {}\n      , t;\n    ctor.prototype = jake.TestTask.prototype;\n    t = new ctor();\n    jake.TestTask.apply(t, arguments);\n    return t;\n  };\n\n})();\n\nmodule.exports = api;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/program.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar fs = require('fs')\n  , parseargs = require('./parseargs')\n  , utils = require('./utils')\n  , Program\n  , optsReg\n  , preempts\n  , usage\n  , die;\n\noptsReg = [\n  { full: 'jakefile'\n  , abbr: 'f'\n  , preempts: false\n  , expectValue: true\n  }\n, { full: 'quiet'\n  , abbr: 'q'\n  , preempts: false\n  , expectValue: false\n  }\n, { full: 'directory'\n  , abbr: 'C'\n  , preempts: false\n  , expectValue: true\n  }\n, { full: 'always-make'\n  , abbr: 'B'\n  , preempts: false\n  , expectValue: false\n  }\n, { full: 'tasks'\n  , abbr: 'T'\n  , preempts: false\n  }\n// Alias ls\n, { full: 'tasks'\n  , abbr: 'ls'\n  , preempts: false\n  }\n, { full: 'trace'\n  , abbr: 't'\n  , preempts: false\n  , expectValue: false\n  }\n, { full: 'help'\n  , abbr: 'h'\n  , preempts: true\n  }\n, { full: 'version'\n  , abbr: 'V'\n  , preempts: true\n  }\n  // Alias lowercase v\n, { full: 'version'\n  , abbr: 'v'\n  , preempts: true\n  }\n, { full: 'jakelibdir'\n  , abbr: 'J'\n  , preempts: false\n  , expectValue: true\n  }\n];\n\npreempts = {\n  version: function () {\n    die(jake.version);\n  }\n, help: function () {\n    die(usage);\n  }\n};\n\nusage = ''\n    + 'Jake JavaScript build tool\\n'\n    + '********************************************************************************\\n'\n    + 'If no flags are given, Jake looks for a Jakefile or Jakefile.js in the current directory.\\n'\n    + '********************************************************************************\\n'\n    + '{Usage}: jake [options ...] [env variables ...] target\\n'\n    + '\\n'\n    + '{Options}:\\n'\n    + '  -f,     --jakefile FILE            Use FILE as the Jakefile.\\n'\n    + '  -C,     --directory DIRECTORY      Change to DIRECTORY before running tasks.\\n'\n    + '  -q,     --quiet                    Do not log messages to standard output.\\n'\n    + '  -B,     --always-make              Unconditionally make all targets.\\n'\n    + '  -T/ls,  --tasks                 Display the tasks (matching optional PATTERN) with descriptions, then exit.\\n'\n    + '  -J,     --jakelibdir JAKELIBDIR    Auto-import any .jake files in JAKELIBDIR. (default is \\'jakelib\\')\\n'\n    + '  -t,     --trace                    Enable full backtrace.\\n'\n    + '  -h,     --help                     Display this help message.\\n'\n    + '  -V/v,   --version                  Display the Jake version.\\n'\n    + '';\n\nProgram = function () {\n  this.opts = {};\n  this.taskNames = null;\n  this.taskArgs = null;\n  this.envVars = null;\n};\n\nProgram.prototype = new (function () {\n\n  this.handleErr = function (err) {\n    if(jake.listeners('error').length !== 0) {\n      jake.emit('error', err);\n      return;\n    }\n\n    var msg;\n\n    if (jake.listeners('error').length) {\n      jake.emit('error', err);\n      return;\n    }\n\n    utils.logger.error('jake aborted.');\n    if (this.opts.trace && err.stack) {\n      utils.logger.error(err.stack);\n    }\n    else {\n      if (err.stack) {\n        msg = err.stack.split('\\n').slice(0, 3).join('\\n');\n        utils.logger.error(msg);\n        utils.logger.error('(See full trace by running task with --trace)');\n      }\n      else {\n        utils.logger.error(err.message);\n      }\n    }\n    process.stdout.write('', function() {\n      process.stderr.write('', function() {\n        jake.errorCode = jake.errorCode || 1;\n        process.exit(jake.errorCode);\n      });\n    });\n  };\n\n  this.parseArgs = function (args) {\n    var result = (new parseargs.Parser(optsReg)).parse(args);\n    this.setOpts(result.opts);\n    this.setTaskNames(result.taskNames);\n    this.setEnvVars(result.envVars);\n  };\n\n  this.setOpts = function (options) {\n    var opts = options || {};\n    utils.mixin(this.opts, opts);\n  };\n\n  this.setTaskNames = function (names) {\n    if (names && !Array.isArray(names)) {\n      throw new Error('Task names must be an array');\n    }\n    this.taskNames = (names && names.length) ? names : ['default'];\n  };\n\n  this.setEnvVars = function (vars) {\n    this.envVars = vars || null;\n  };\n\n  this.firstPreemptiveOption = function () {\n    var opts = this.opts;\n    for (var p in opts) {\n      if (preempts[p]) {\n        return preempts[p];\n      }\n    }\n    return false;\n  };\n\n  this.init = function (configuration) {\n    var self = this\n      , config = configuration || {};\n    if (config.options) {\n      this.setOpts(config.options);\n    }\n    if (config.taskNames) {\n      this.setTaskNames(config.taskNames);\n    }\n    if (config.envVars) {\n      this.setEnvVars(config.envVars);\n    }\n    process.addListener('uncaughtException', function (err) {\n      self.handleErr(err);\n    });\n    if (this.envVars) {\n      utils.mixin(process.env, this.envVars);\n    }\n  };\n\n  this.run = function () {\n    var rootTask\n      , taskNames\n      , dirname\n      , opts = this.opts;\n\n    // Run with `jake -T`, just show descriptions\n    if (opts.tasks) {\n      return jake.showAllTaskDescriptions(opts.tasks);\n    }\n\n    taskNames = this.taskNames;\n    if (!(Array.isArray(taskNames) && taskNames.length)) {\n      throw new Error('Please pass jake.runTasks an array of task-names');\n    }\n\n    // Set working dir\n    dirname = opts.directory;\n    if (dirname) {\n      if (utils.file.existsSync(dirname) &&\n        fs.statSync(dirname).isDirectory()) {\n        process.chdir(dirname);\n      }\n      else {\n        throw new Error(dirname + ' is not a valid directory path');\n      }\n    }\n\n    task('__root__', taskNames, function () {});\n\n    rootTask = jake.Task.__root__;\n    rootTask.once('complete', function () {\n      jake.emit('complete');\n    });\n    jake.emit('start');\n    rootTask.invoke();\n  };\n\n})();\n\ndie = function (msg) {\n  console.log(msg);\n  process.stdout.write('', function() {\n    process.stderr.write('', function() {\n      process.exit();\n\t});\n  });\n};\n\nmodule.exports.Program = Program;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/parseargs.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar parseargs = {};\n\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null;\n\n  // Data structures used for parsing\n  this.reg = [];\n  this.shortOpts = {};\n  this.longOpts = {};\n\n  var item;\n  for (var i = 0, ii = opts.length; i < ii; i++) {\n    item = opts[i];\n    this.shortOpts[item.abbr] = item;\n    this.longOpts[item.full] = item;\n  }\n  this.reg = opts;\n};\n\nparseargs.Parser.prototype = new function () {\n\n  var _trueOrNextVal = function (argParts, args) {\n        if (argParts[1]) {\n          return argParts[1];\n        }\n        else {\n          return (!args[0] || (args[0].indexOf('-') === 0)) ?\n              true : args.shift();\n        }\n      };\n\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n  this.parse = function (args) {\n    var cmds = []\n      , cmd\n      , envVars = {}\n      , opts = {}\n      , arg\n      , argItem\n      , argParts\n      , cmdItems\n      , taskNames = []\n      , preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (arg.indexOf('-') === 0) {\n        arg = arg.replace(/^--/, '').replace(/^-/, '');\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          }\n          // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n          if (argItem.expectValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            if (!opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          }\n          else {\n            opts[argItem.full] = true;\n          }\n        }\n      }\n      else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while (!!(cmd = cmds.pop())) {\n        cmdItems = cmd.split('=');\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        }\n        else {\n          taskNames.push(cmd);\n        }\n      }\n\n    }\n\n    return {\n      opts: opts\n    , envVars: envVars\n    , taskNames: taskNames\n    };\n  };\n\n};\n\nmodule.exports = parseargs;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/loader.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar path = require('path')\n  , fs = require('fs')\n  , existsSync = typeof fs.existsSync == 'function' ?\n      fs.existsSync : path.existsSync\n  , utils = require('utilities')\n  , CoffeeScript\n  , LiveScript\n  , Loader;\n\n\nLoader = function () {\n\n  var JAKEFILE_PAT = /\\.jake(\\.js|\\.coffee|\\.ls)?$/;\n\n  var _requireCoffee = function () {\n        try {\n          var cs = require('coffee-script');\n          // Ensure we support CoffeeScript versions older than 1.7.0\n          if (typeof cs.register == 'function') {\n            cs.register();\n          }\n        }\n        catch (e) {\n          fail('CoffeeScript is missing! Try `npm install coffee-script`');\n        }\n        return(cs);\n      };\n\n  var _requireLiveScript = function () {\n    try {\n      return require('livescript');\n    } catch (e) {}\n    try {\n      return require('LiveScript');\n    } catch (e) {}\n    fail('LiveScript is missing! Try `npm install livescript`');\n  };\n\n  this.loadFile = function (file) {\n    var jakefile = file ?\n            file.replace(/\\.js$/, '').replace(/\\.coffee$/, '').replace(/\\.ls/, '') : 'Jakefile'\n      , fileSpecified = !!file\n      // Dear God, why?\n      , isCoffee = false\n      , isLiveScript = false\n      // Warning, recursive\n      , exists\n      , oldCwd = process.cwd();\n\n    exists = function () {\n      var cwd = process.cwd();\n      if (existsSync(jakefile) || existsSync(jakefile + '.js') ||\n        existsSync(jakefile + '.coffee') || existsSync(jakefile + '.ls')) {\n        return true;\n      }\n      if (!fileSpecified) {\n        process.chdir(\"..\");\n        if (cwd === process.cwd()) {\n          // Restore the working directory on failure\n          process.chdir(oldCwd);\n          return false;\n        }\n        return exists();\n      }\n    };\n\n    if (!exists()) {\n      return false;\n    }\n\n    isCoffee = existsSync(jakefile + '.coffee');\n    isLiveScript = existsSync(jakefile + '.ls');\n    if (isCoffee) {\n      CoffeeScript = _requireCoffee();\n    }\n    if (isLiveScript) {\n        LiveScript = _requireLiveScript();\n    }\n    require(utils.file.absolutize(jakefile));\n    return true;\n  };\n\n  this.loadDirectory = function (d) {\n    var dirname = d || 'jakelib'\n      , dirlist;\n    dirname = utils.file.absolutize(dirname);\n    if (existsSync(dirname)) {\n      dirlist = fs.readdirSync(dirname);\n      dirlist.forEach(function (filePath) {\n        if (JAKEFILE_PAT.test(filePath)) {\n          if (/\\.coffee$/.test(filePath)) {\n            CoffeeScript = _requireCoffee();\n          }\n          if (/\\.ls$/.test(filePath)) {\n            LiveScript = _requireLiveScript();\n          }\n          require(path.join(dirname, filePath));\n        }\n      });\n      return true;\n    }\n\n    return false;\n  };\n};\n\nmodule.exports.Loader = Loader;\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/package_task.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar path = require('path')\n  , fs = require('fs')\n  , exec = require('child_process').exec\n  , FileList = require('filelist').FileList;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  var t = new jake.PackageTask('rous', 'v' + version, function () {\n    var files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\nvar PackageTask = function () {\n  var args = Array.prototype.slice.call(arguments)\n    , name = args.shift()\n    , version = args.shift()\n    , definition = args.pop()\n    , prereqs = args.pop() || []; // Optional\n\n    prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\nPackageTask.prototype = new (function () {\n\n  var _compressOpts = {\n        Tar: {\n          ext: '.tgz'\n        , flags: 'czf'\n        , cmd: 'tar'\n        }\n      , TarGz: {\n          ext: '.tar.gz'\n        , flags: 'czf'\n        , cmd: 'tar'\n        }\n      , TarBz2: {\n          ext: '.tar.bz2'\n        , flags: 'cjf'\n        , cmd: 'tar'\n        }\n      , Jar: {\n          ext: '.jar'\n        , flags: 'cf'\n        , cmd: 'jar'\n        }\n      , Zip: {\n          ext: '.zip'\n        , flags: 'qr'\n        , cmd: 'zip'\n        }\n      };\n\n  this.define = function () {\n    var self = this\n      , packageDirPath = this.packageDirPath()\n      , compressTaskArr = [];\n\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage']));\n    // Backward-compat alias\n    task('repackage', ['package']);\n\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {silent: true});\n    });\n\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    var doCommand = function (p) {\n      var filename = path.resolve(self.packageDir + '/' + self.packageName() +\n                                  _compressOpts[p].ext);\n      if (process.platform == 'win32') {\n          // Windows full path may have drive letter, which is going to cause\n          // namespace problems, so strip it.\n          if (filename.length > 2 && filename[1] == ':') {\n            filename = filename.substr(2);\n          }\n      }\n      compressTaskArr.push(filename);\n\n      file(filename, [packageDirPath], function () {\n        var cmd\n        , opts = _compressOpts[p]\n        // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n        , chdir = self.packageDir\n        // Save the current dir so it's possible to pop back up\n        // after compressing\n        , currDir = process.cwd()\n        , archiveChangeDir\n        , archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        }\n        else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        }\n\n        // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        }\n\n        // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          }\n          else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        }\n\n        // Where to get the archive content\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        }\n        else {\n          cmd += ' ' + self.packageName();\n        }\n\n        // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n        process.chdir(chdir);\n\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) { throw err; }\n\n          // Return back up to the starting directory (see above,\n          // before exec)\n          process.chdir(currDir);\n\n          complete();\n        });\n      }, {async: true});\n    };\n\n    for (var p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n\n    directory(this.packageDir);\n\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      var fileList = [];\n      self.packageFiles.forEach(function (name) {\n        var f = path.join(self.packageDirPath(), name)\n          , fDir = path.dirname(f)\n          , stats;\n        jake.mkdirP(fDir, {silent: true});\n\n        // Add both files and directories\n        fileList.push({\n          from: name\n        , to: f\n        });\n      });\n      var _copyFile = function () {\n        var cmd\n          , file = fileList.pop()\n          , stat;\n        if (file) {\n          stat = fs.statSync(file.from);\n          // Target is a directory, just create it\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {silent: true});\n            _copyFile();\n          }\n          // Otherwise copy the file\n          else {\n            jake.cpR(file.from, file.to, {silent: true});\n            _copyFile();\n          }\n        }\n        else {\n          complete();\n        }\n      };\n      _copyFile();\n    }, {async: true});\n\n\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    }\n    else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n\n})();\n\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/publish_task.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar fs = require('fs')\n  , path = require('path')\n  , exec = require('child_process').exec\n  , utils = require('utilities')\n  , FileList = require('filelist').FileList;\n\nvar PublishTask = function () {\n  var args = Array.prototype.slice.call(arguments).filter(function (item) {\n        return typeof item != 'undefined';\n      })\n    , arg\n    , opts = {}\n    , definition\n    , prereqs = []\n    , createDef = function (arg) {\n        return function () {\n          this.packageFiles.include(arg);\n        };\n      };\n\n  this.name = args.shift();\n\n  // Old API, just name + list of files\n  if (args.length == 1 && (Array.isArray(args[0]) || typeof args[0] == 'string')) {\n    definition = createDef(args.pop());\n  }\n  // Current API, name + [prereqs] + [opts] + definition\n  else {\n    while ((arg = args.pop())) {\n      // Definition func\n      if (typeof arg == 'function') {\n        definition = arg;\n      }\n      // Prereqs\n      else if (Array.isArray(arg) || typeof arg == 'string') {\n        prereqs = arg;\n      }\n      // Opts\n      else {\n        opts = arg;\n      }\n    }\n  }\n\n  this.prereqs = prereqs;\n  this.packageFiles = new FileList();\n  this.publishCmd = opts.publishCmd || 'npm publish %filename';\n  this.publishMessage = opts.publishMessage || 'BOOM! Published.';\n  this.gitCmd = opts.gitCmd || 'git';\n  this.versionFiles = opts.versionFiles || ['package.json'];\n  this.scheduleDelay = 5000;\n\n  // Override utility funcs for testing\n  this._ensureRepoClean = function (stdout) {\n    if (stdout.length) {\n      fail(new Error('Git repository is not clean.'));\n    }\n  };\n  this._getCurrentBranch = function (stdout) {\n    return utils.string.trim(stdout);\n  };\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\n\nPublishTask.prototype = new (function () {\n\n  var _currentBranch = null;\n\n  var getPackage = function () {\n        var pkg = JSON.parse(fs.readFileSync(path.join(process.cwd(),\n            '/package.json')).toString());\n        return pkg;\n      }\n    , getPackageVersionNumber = function () {\n        return getPackage().version;\n      };\n\n  this.define = function () {\n    var self = this;\n\n    namespace('publish', function () {\n      task('fetchTags', {async: true}, function () {\n        // Make sure local tags are up to date\n        var cmds = [\n          self.gitCmd + ' fetch --tags'\n        ];\n        jake.exec(cmds, function () {\n          console.log('Fetched remote tags.');\n          complete();\n        });\n      });\n\n      task('getCurrentBranch', {async: true}, function () {\n        // Figure out what branch to push to\n        exec(self.gitCmd + ' symbolic-ref --short HEAD',\n            function (err, stdout, stderr) {\n          if (err) {\n            fail(err);\n          }\n          if (stderr) {\n            fail(new Error(stderr));\n          }\n          if (!stdout) {\n            fail(new Error('No current Git branch found'));\n          }\n          _currentBranch = self._getCurrentBranch(stdout);\n          console.log('On branch ' + _currentBranch);\n          complete();\n        });\n      });\n\n      task('ensureClean', {async: true}, function () {\n        // Only bump, push, and tag if the Git repo is clean\n        exec(self.gitCmd + ' status --porcelain --untracked-files=no',\n            function (err, stdout, stderr) {\n          if (err) {\n            fail(err);\n          }\n          if (stderr) {\n            fail(new Error(stderr));\n          }\n\n          // Throw if there's output\n          self._ensureRepoClean(stdout);\n\n          complete();\n        });\n      });\n\n      task('updateVersionFiles', function () {\n        var pkg\n          , version\n          , arr\n          , patch;\n\n        // Grab the current version-string\n        pkg = getPackage();\n        version = pkg.version;\n        // Increment the patch-number for the version\n        arr = version.split('.');\n        patch = parseInt(arr.pop(), 10) + 1;\n        arr.push(patch);\n        version = arr.join('.');\n\n        // Update package.json or other files with the new version-info\n        self.versionFiles.forEach(function (file) {\n          var p = path.join(process.cwd(), file)\n            , data = JSON.parse(fs.readFileSync(p).toString());\n          data.version = version;\n          fs.writeFileSync(p, JSON.stringify(data, true, 2) + '\\n');\n        });\n        // Return the version string so that listeners for the 'complete' event\n        // for this task can use it (e.g., to update other files before pushing\n        // to Git)\n        return version;\n      });\n\n      task('pushVersion', ['ensureClean', 'updateVersionFiles'], {async: true},\n          function () {\n        var version = getPackageVersionNumber()\n          , message = 'Version ' + version\n          , cmds = [\n              self.gitCmd + ' commit -a -m \"' + message + '\"'\n            , self.gitCmd + ' push origin ' + _currentBranch\n            , self.gitCmd + ' tag -a v' + version + ' -m \"' + message + '\"'\n            , self.gitCmd + ' push --tags'\n            ];\n\n        var execOpts = {};\n        if (process.platform == 'win32') {\n          // Windows won't like the quotes in our cmdline\n          execOpts.windowsVerbatimArguments = true;\n        }\n\n        jake.exec(cmds, function () {\n          var version = getPackageVersionNumber();\n          console.log('Bumped version number to v' + version + '.');\n          complete();\n        }, execOpts);\n\n      });\n\n      task('definePackage', function () {\n        var version = getPackageVersionNumber()\n          , t;\n        t = new jake.PackageTask(self.name, 'v' + version, self.prereqs, function () {\n          // Replace the PackageTask's FileList with the PublishTask's FileList\n          this.packageFiles = self.packageFiles;\n          this.needTarGz = true; // Default to tar.gz\n          // If any of the need<CompressionFormat> or archive opts are set\n          // proxy them to the PackageTask\n          for (var p in this) {\n            if (p.indexOf('need') === 0 || p.indexOf('archive') === 0) {\n              if (typeof self[p] != 'undefined') {\n                this[p] = self[p];\n              }\n            }\n          }\n        });\n      });\n\n      task('package', {async: true}, function () {\n        var definePack = jake.Task['publish:definePackage']\n          , pack = jake.Task.package\n          , version = getPackageVersionNumber();\n\n        // May have already been run\n        definePack.reenable(true);\n        definePack.addListener('complete', function () {\n          pack.addListener('complete', function () {\n            console.log('Created package for ' + self.name + ' v' + version);\n            complete();\n          });\n          pack.invoke();\n        });\n        definePack.invoke();\n      });\n\n      task('publish', {async: true}, function () {\n        var version = getPackageVersionNumber()\n          , filename\n          , cmd;\n\n        console.log('Publishing ' + self.name + ' v' + version);\n\n        if (typeof self.createPublishCommand == 'function') {\n          cmd = self.createPublishCommand(version);\n        }\n        else {\n          filename = 'pkg/' + self.name + '-v' + version + '.tar.gz';\n          cmd = self.publishCmd.replace(/%filename/gi, filename);\n        }\n\n        if (typeof cmd == 'function') {\n          cmd(function (err) {\n            if (err) {\n              throw err;\n            }\n            console.log(self.publishMessage);\n            complete();\n          });\n        }\n        else {\n          // Hackity hack -- NPM publish sometimes returns errror like:\n          // Error sending version data\\nnpm ERR!\n          // Error: forbidden 0.2.4 is modified, should match modified time\n          setTimeout(function () {\n            jake.exec(cmd, function () {\n              console.log(self.publishMessage);\n              complete();\n            }, {printStdout: true, printStderr: true});\n          }, self.scheduleDelay);\n        }\n      });\n\n      task('cleanup', {async: true}, function () {\n        var clobber = jake.Task.clobber;\n        clobber.reenable(true);\n        clobber.on('complete', function () {\n          console.log('Cleaned up package');\n          complete();\n        });\n        clobber.invoke();\n      });\n\n    });\n\n    var prefixNs = function (item) {\n      return 'publish:' + item;\n    };\n\n    // Create aliases in the default namespace\n    desc('Create a new version and release.');\n    task('publish', self.prereqs.concat(['version', 'release']\n        .map(prefixNs)));\n\n    desc('Release the existing version.');\n    task('publishExisting', self.prereqs.concat(['release']\n        .map(prefixNs)));\n\n    task('version', ['fetchTags', 'getCurrentBranch', 'pushVersion']\n        .map(prefixNs));\n\n    task('release', ['package', 'publish', 'cleanup']\n        .map(prefixNs));\n\n    // Invoke proactively so there will be a callable 'package' task\n    // which can be used apart from 'publish'\n    jake.Task['publish:definePackage'].invoke();\n  };\n\n})();\n\njake.PublishTask = PublishTask;\nexports.PublishTask = PublishTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/watch_task.js":"var fs = require('fs')\n  , FileList = require('filelist').FileList;\n\nvar THROTTLE = 5000;\n\n/**\n  @name WatchTask\n  @constructor\n  @description  Watches specified files for changes, and runs a\n      set of tasks each time there's a change\n  @param {String} [name] Name of the WatchTask -- defaults to 'watch'\n      if not specified\n  @param {Array} taskNames The list of tasks to run with each change\n  @param {Function} definition Function to set up the WatchTask --\n      invoked on `this` after the initial construction\n*/\nvar WatchTask = function () {\n  var self = this\n    , args = Array.prototype.slice.call(arguments)\n    , arg\n    , definition\n    , taskNames\n    , name\n    , last = (new Date()).getTime() - THROTTLE;\n\n  args = args.filter(function (a) {\n    return !!a;\n  });\n\n  while ((arg = args.shift())) {\n    if (typeof arg == 'string') {\n      name = arg;\n    }\n    else if (typeof arg == 'object' && Array.isArray(arg)) {\n      taskNames = arg;\n    }\n    else if (typeof arg == 'function') {\n      definition = arg;\n    }\n  }\n\n  if (!(taskNames && taskNames.length)) {\n    throw new Error('Watch task needs some tasks to run');\n  }\n\n  name = name || 'watch';\n  definition = definition || function () {};\n\n  if (jake.Task[name]) {\n    throw new Error('WatchTask named \"' + name + '\" already exists. ' +\n      'Please use a different name.');\n  }\n\n  this.watchTasks = Array.isArray(taskNames) ? taskNames : [taskNames];\n  this.watchFiles = new FileList();\n  this.rootTask = task('watchTasks', this.watchTasks);\n  this.throttle = THROTTLE;\n\n  this.watchFiles.include(WatchTask.DEFAULT_INCLUDE_FILES);\n  this.watchFiles.exclude(WatchTask.DEFAULT_EXCLUDE_FILES);\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n\n  desc('Runs these tasks: ' + this.watchTasks.join(', '));\n  task(name, function () {\n    console.log('WatchTask started for: ' + self.watchTasks.join(', '));\n    jake.watch('.', {includePattern: /.+/}, function (filePath) {\n      var fileMatch = self.watchFiles.toArray().some(function (item) {\n        return item == filePath;\n      });\n      if (fileMatch && ((new Date()).getTime() - last) > self.throttle) {\n        last = (new Date()).getTime();\n        self.rootTask.reenable(true);\n        self.rootTask.invoke();\n      }\n    });\n  });\n};\n\nWatchTask.DEFAULT_INCLUDE_FILES = [\n  './**/*.js'\n, './**/*.coffee'\n, './**/*.ls'\n, './**/*.css'\n, './**/*.less'\n, './**/*.scss'\n];\n\nWatchTask.DEFAULT_EXCLUDE_FILES = [];\nif (fs.existsSync('node_modules')) {\n  WatchTask.DEFAULT_EXCLUDE_FILES.push(/(^|[\\/\\\\])node_modules([\\/\\\\]|$)/);\n}\n\nexports.WatchTask = WatchTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/lib/test_task.js":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nvar path = require('path')\n  , fs = require('fs')\n  , exec = require('child_process').exec\n  , currDir = process.cwd();\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.TestTask\n  @constructor\n  @description Instantiating a TestTask creates a number of Jake\n  Tasks that make running tests for your software easy.\n\n  @param {String} name The name of the project\n  @param {Function} definition Defines the list of files containing the tests,\n  and the name of the namespace/task for running them. Will be executed on the\n  instantiated TestTask (i.e., 'this', will be the TestTask instance), to set\n  the various instance-propertiess.\n\n  @example\n  var t = new jake.TestTask('bij-js', function () {\n    this.testName = 'testSpecial';\n    this.testFiles.include('test/**');\n  });\n\n */\nvar TestTask = function () {\n  var self = this\n    , args = Array.prototype.slice.call(arguments)\n    , name = args.shift()\n    , definition = args.pop()\n    , prereqs = args.pop() || [];\n\n  /**\n    @name jake.TestTask#testNam\n    @public\n    @type {String}\n    @description The name of the namespace to place the tests in, and\n    the top-level task for running tests. Defaults to \"test\"\n   */\n  this.testName = 'test';\n\n  /**\n    @name jake.TestTask#testFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files containing tests to load\n   */\n  this.testFiles = new jake.FileList();\n\n  /**\n    @name jake.TestTask#showDescription\n    @public\n    @type {Boolean}\n    @description Show the created task when doing Jake -T\n   */\n  this.showDescription = true;\n\n  /*\n    @name jake.TestTask#totalTests\n    @public\n    @type {Number}\n    @description The total number of tests to run\n  */\n  this.totalTests = 0;\n\n  /*\n    @name jake.TestTask#executedTests\n    @public\n    @type {Number}\n    @description The number of tests successfully run\n  */\n  this.executedTests = 0;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n\n  if (this.showDescription) {\n    desc('Run the tests for ' + name);\n  }\n\n  task(this.testName, prereqs, {async: true}, function () {\n    var t = jake.Task[self.testName + ':run'];\n    t.on('complete', function () {\n      complete();\n    });\n    // Pass args to the namespaced test\n    t.invoke.apply(t, arguments);\n  });\n\n  namespace(self.testName, function () {\n\n    task('run', {async: true}, function (pat) {\n      var p = pat || '.*'\n        , re\n        , testFiles;\n\n      // Don't nest; make a top-level namespace. Don't want\n      // re-calling from inside to nest infinitely\n     jake.currentNamespace = jake.defaultNamespace;\n\n      re = new RegExp(pat);\n      // Get test files that match the passed-in pattern\n      testFiles = self.testFiles.toArray()\n          .filter(function (f) {\n        return (re).test(f);\n      }) // Don't load the same file multiple times -- should this be in FileList?\n          .reduce(function(p, c) {\n        if (p.indexOf(c) < 0) {\n          p.push(c);\n        }\n        return p;\n      }, []);\n\n      // Create a namespace for all the testing tasks to live in\n      namespace(self.testName + 'Exec', function () {\n        // Each test will be a prereq for the dummy top-level task\n        var prereqs = []\n        // Continuation to pass to the async tests, wrapping `continune`\n          , next = function () {\n              complete();\n            }\n        // Create the task for this test-function\n          , createTask = function (name, action) {\n              // If the test-function is defined with a continuation\n              // param, flag the task as async\n              var t\n                , isAsync = !!action.length;\n\n              // Define the actual namespaced task with the name, the\n              // wrapped action, and the correc async-flag\n              t = task(name, createAction(name, action), {\n                async: isAsync\n              });\n              t.once('complete', function () {\n                self.executedTests++;\n              });\n            }\n        // Used as the action for the defined task for each test.\n          , createAction = function (n, a) {\n              // A wrapped function that passes in the `next` function\n              // for any tasks that run asynchronously\n              return function () {\n                var cb\n                  , msg;\n                if (a.length) {\n                  cb = next;\n                }\n                if (!(n == 'before' || n == 'after' ||\n                    /_beforeEach$/.test(n) || /_afterEach$/.test(n))) {\n                  if (n.toLowerCase().indexOf('test') === 0) {\n                    msg = n;\n                  }\n                  else {\n                    msg = 'test ' + n;\n                  }\n                  jake.logger.log(n);\n                }\n                // 'this' will be the task when action is run\n                return a.call(this, cb);\n              };\n            }\n          // Dummy top-level task for everything to be prereqs for\n          , topLevel;\n\n        // Pull in each test-file, and iterate over any exported\n        // test-functions. Register each test-function as a prereq task\n        testFiles.forEach(function (file) {\n          var exp = require(path.join(currDir, file))\n            , name\n            , action\n            , isAsync;\n\n          // Create a namespace for each filename, so test-name collisions\n          // won't be a problem\n          namespace(file, function () {\n            var testPrefix = self.testName + 'Exec:' + file + ':'\n              , testName;\n            // Dummy task for displaying file banner\n            testName = '*** Running ' + file + ' ***';\n            prereqs.push(testPrefix + testName);\n            createTask(testName, function () {});\n\n            // 'before' setup\n            if (typeof exp.before == 'function') {\n              prereqs.push(testPrefix + 'before');\n              // Create the task\n              createTask('before', exp.before);\n            }\n\n            // Walk each exported function, and create a task for each\n            for (var p in exp) {\n              if (p == 'before' || p == 'after' ||\n                  p == 'beforeEach' || p == 'afterEach') {\n                continue;\n              }\n\n              if (typeof exp.beforeEach == 'function') {\n                prereqs.push(testPrefix + p + '_beforeEach');\n                // Create the task\n                createTask(p + '_beforeEach', exp.beforeEach);\n              }\n\n              // Add the namespace:name of this test to the list of prereqs\n              // for the dummy top-level task\n              prereqs.push(testPrefix + p);\n              // Create the task\n              createTask(p, exp[p]);\n\n              if (typeof exp.afterEach == 'function') {\n                prereqs.push(testPrefix + p + '_afterEach');\n                // Create the task\n                createTask(p + '_afterEach', exp.afterEach);\n              }\n            }\n\n            // 'after' teardown\n            if (typeof exp.after == 'function') {\n              prereqs.push(testPrefix + 'after');\n              // Create the task\n              createTask('after', exp.after);\n            }\n\n          });\n        });\n\n        self.totalTests = prereqs.length;\n        process.on('exit', function () {\n          // Throw in the case where the process exits without\n          // finishing tests, but no error was thrown\n          if (!jake.errorCode && (self.totalTests > self.executedTests)) {\n            throw new Error('Process exited without all tests completing.');\n          }\n        });\n\n        // Create the dummy top-level task. When calling a task internally\n        // with `invoke` that is async (or has async prereqs), have to listen\n        // for the 'complete' event to know when it's done\n        topLevel = task('__top__', prereqs);\n        topLevel.addListener('complete', function () {\n          jake.logger.log('All tests ran successfully');\n          complete();\n        });\n\n        topLevel.invoke(); // Do the thing!\n      });\n\n    });\n  });\n\n\n};\n\njake.TestTask = TestTask;\nexports.TestTask = TestTask;\n\n","/home/travis/build/npmtest/node-npmtest-jake/node_modules/jake/bin/cli.js":"#!/usr/bin/env node\n/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n// Load `jake` global\nrequire('../lib/jake');\n\nvar args = process.argv.slice(2);\n\njake.run.apply(jake, args);\n"}